package gateway

import (
	"bytes"
	"github.com/rs/zerolog/log"
)

func SplitMessage(segment []byte) (messages [][]byte, residueBytes []byte, invalidMessages [][]byte) {
	//segment = []byte{0x7e, 0x02}
	//segment = []byte{0x02, 0x03, 0x05, 0x06, 0x07}
	//segment = []byte{0x02, 0x03, 0x05, 0x06, 0x7e, 0x02}
	//segment = []byte{0x7e, 0x02, 0x02, 0x03, 0x05, 0x06, 0x07}
	//segment = []byte{0x7e, 0x02, 0x02, 0x03, 0x05, 0x06, 0x07, 0x7e, 0x02}
	//segment = []byte{0x7e, 0x02, 0x02, 0x03, 0x05, 0x06, 0x07, 0x7e, 0x02, 0x7e, 0x02, 0x02, 0x7e, 0x02}
	//segment = []byte{0x7e, 0x02, 0x02, 0x03, 0x05, 0x06, 0x07, 0x7e, 0x02, 0x7e, 0x02, 0x02, 0x7e, 0x02, 0x7e, 0x02, 0x03, 0x05}
	//segment = []byte{0x7e, 0x02, 0x02, 0x03, 0x05, 0x06, 0x07, 0x7e, 0x02, 0x77, 0x7e, 0x02, 0x02, 0x7e, 0x02, 0x7e, 0x02, 0x03, 0x05}
	//segment = []byte{0x7e, 0x02, 0x02, 0x03, 0x05, 0x06, 0x07, 0x7e, 0x02, 0x77, 0x7e, 0x02, 0x02, 0x7e, 0x02}
	//segment = []byte{0x7e, 0x02, 0x02, 0x03, 0x05, 0x06, 0x07, 0x7e, 0x02, 0x77, 0x7e, 0x02, 0x02, 0x7e, 0x02, 0x77}

	//segment = []byte{0xff, 0xff, 0x7e, 0x02, 0x02, 0x03, 0x05, 0x06, 0x07, 0x7e, 0x02, 0x77, 0x7e, 0x02, 0x02, 0x7e, 0x02, 0x77}
	//segment = []byte{0xff, 0xff, 0x7e, 0x02, 0x02, 0x03, 0x05, 0x06, 0x07, 0x7e, 0x02, 0x77, 0x7e, 0x02, 0x7e, 0x02, 0x77}
	//segment = []byte{0x7e, 0x03, 0x05, 0x06, 0x07, 0x7e, 0x02, 0x77}
	//segment = []byte{0x7e, 0x03, 0x05, 0x06, 0x07, 0x7e, 0x02, 0x77, 0x7e, 0x02}
	//segment = []byte{0x7e, 0x02, 0x03, 0x05, 0x06, 0x07, 0x7e, 0x02, 0x77}
	//segment = []byte{0x7e, 0x03, 0x05, 0x06, 0x07, 0x7e, 0x02, 0x77, 0x7e, 0x02, 0x77}
	//segment = []byte{0x77, 0x01, 0x7e, 0x02,   0x7e, 0x02, 0x02, 0x03, 0x05, 0x06, 0x07}
	if len(segment) < 12 {
		residueBytes = append(residueBytes, segment...)
		return
	}
	jtt808StartFlag := 0x7e
	var indexList []int
	for index := 0; index < len(segment); index++ {
		sf := int(segment[index])
		if sf == jtt808StartFlag {
			// 7e list
			indexList = append(indexList, index)
		}
	}
	messages, residueBytes, invalidMessages = SplitPackage(segment, indexList)
	return
}

func SplitPackage(segment []byte, indexList []int) (messages [][]byte, residueBytes []byte, invalidMessages [][]byte) {
	old7e := []byte{0x7d, 0x02}
	source7e := []byte{0x7e}

	old7d := []byte{0x7d, 0x01}
	source7d := []byte{0x7d}
	var entireList []int

	if len(indexList) == 0 {
		residueBytes = append(residueBytes, segment...)
		return
	} else if len(indexList) == 1 {
		left := indexList[0]
		residueBytes = append(residueBytes, segment[left:]...) // 尾
		data := segment[:left]
		invalidMessages = append(invalidMessages, data)
		return
	}

	if len(indexList)%2 != 0 {
		// 有剩余
		entireList = indexList[:len(indexList)-1]
		tail := indexList[len(indexList)-1]
		residueBytes = append(residueBytes, segment[tail:]...) // 尾
		// 7e --- 7e xx 7e 04 03  中间的xx为无效数据
		data := segment[entireList[len(entireList)-1]+1 : tail]
		invalidMessages = append(invalidMessages, data)
	} else {
		// 包完整
		entireList = indexList
		tail := indexList[len(indexList)-1]
		tail += 1
		if tail == len(segment) { // 末尾为0x7e
			residueBytes = append(residueBytes, segment[tail:]...) // 尾
		} else {
			// 中间存在0x7e, 剩下的数据为异常数据
			invalidMessages = append(invalidMessages, segment[tail:])
		}
	}
	head := segment[:indexList[0]]
	invalidMessages = append(invalidMessages, head) // 头

	for index := 0; index < len(entireList)-1; index++ {
		if index%2 == 0 {
			// 起始 -- 结束 中间数据为完整数据包
			data := segment[entireList[index] : entireList[index+1]+1]
			log.Info().Msgf("data is: %x", data)
			pkg := bytes.Replace(data, old7e, source7e, -1)
			pkg = bytes.Replace(pkg, old7d, source7d, -1)
			messages = append(messages, pkg)
		} else {
			// 结束 -- 起始  中间的数据写入无效buffer
			data := segment[entireList[index]+1 : entireList[index+1]]
			if data != nil {
				invalidMessages = append(invalidMessages, data)
			}
		}
	}
	return
}
